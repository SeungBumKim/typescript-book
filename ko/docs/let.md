### let

`var`는 JavaScript의 *함수 범위*의 변수입니다. 이런한 범위는 다른 많은 언어(C# / Java 등)의 변수의 *블럭 범위*는 다릅니다. 만약 *블럭 범위* 기준을 JavaScript에 적용하면, `123`이 출력되는 것을 기대할 것이나 `456`이 출력됩니다:

```ts
var foo = 123;
if (true) {
    var foo = 456;
}
console.log(foo); // 456
```
이는 `{`이 *변수의 범위* 생성하지 않기 때문입니다. 변수 `foo`는 *블럭*안의 것과 블럭밖의 것이 동일합니다. 이는 JavaScript 프로그래밍에서 대게 잘못사용는 소스코입니다. 그래서 TypeScript(그리고 ES6)에서는 *블럭 범위*의 변수를 정의하는 키워드 `let`을 추가하였습니다. `var`대신에 `let`을 사용하면 범위밖에서 정의한 것과 분리된 진정한 고유 요소를 얻게됩니다. 아래 동일한 예제로 `let`을 설명할 수 있습니다.
This is because `{` does not create a new *variable scope*. The variable `foo` is the same inside the if *block* as it is outside the if block. This is a common source of errors in JavaScript programming. This is why TypeScript (and ES6) introduces the `let` keyword to allow you to define variables with true *block scope*. That is if you use `let` instead of `var` you get a true unique element disconnected from what you might have defined outside the scope. The same example is demonstrated with `let`:

```ts
let foo = 123;
if (true) {
    let foo = 456;
}
console.log(foo); // 123
```

`let`이 에러를 방지 할 수있는 또 다른 장소는 루프입니다.
```ts
var index = 0;
var array = [1, 2, 3];
for (let index = 0; index < array.length; index++) {
    console.log(array[index]);
}
console.log(index); // 0
```
신규 및 기존 다른언어 개발자들에게는 덜놀랍겠지만 가능하면 언제든지 `let`을 사용하는 것이 더 낫다는 것을 발견 할 수 있습니다.

#### Functions create a new scope
Since we mentioned it, we'd like to demonstrate that functions create a new variable scope in JavaScript. Consider the following:

```ts
var foo = 123;
function test() {
    var foo = 456;
}
test();
console.log(foo); // 123
```
This behaves as you would expect. Without this it would be very difficult to write code in JavaScript.

#### Generated JS
The JS generated by TypeScript is simple renaming of the `let` variable if a similar name already exists in the surrounding scope. E.g. the following is generated as is with a simple replacement of `var` with `let`:

```ts
if (true) {
    let foo = 123;
}

// becomes //

if (true) {
    var foo = 123;
}
```
However if the variable name is already taken by the surrounding scope then a new variable name is generated as shown (notice `_foo`):

```ts
var foo = '123';
if (true) {
    let foo = 123;
}

// becomes //

var foo = '123';
if (true) {
    var _foo = 123; // Renamed
}
```

#### let in closures
A common programming interview question for a JavaScript developer is what is the log of this simple file:

```ts
var funcs = [];
// create a bunch of functions
for (var i = 0; i < 3; i++) {
    funcs.push(function() {
        console.log(i);
    })
}
// call them
for (var j = 0; j < 3; j++) {
    funcs[j]();
}
```
One would have expected it to be `0,1,2`. Surprisingly it is going to be `3` for all three functions. Reason is that all three functions are using the variable `i` from the outer scope and at the time we execute them (in the second loop) the value of `i` will be `3` (that's the termination condition for the first loop).

A fix would be to create a new variable in each loop specific to that loop iteration. As we've learnt before we can create a new variable scope by creating a new function and immediately executing it (i.e. the IIFE pattern from classes `(function() { /* body */ })();`) as shown below:

```ts
var funcs = [];
// create a bunch of functions
for (var i = 0; i < 3; i++) {
    (function() {
        var local = i;
        funcs.push(function() {
            console.log(local);
        })
    })();
}
// call them
for (var j = 0; j < 3; j++) {
    funcs[j]();
}
```
Here the functions close over (hence called a `closure`) the *local* variable (conveniently named `local`) and use that instead of the loop variable `i`.

> Note that closures come with a performance impact (they need to store the surrounding state).

The ES6 `let` keyword in a loop would have the same behavior as the previous example:

```ts
var funcs = [];
// create a bunch of functions
for (let i = 0; i < 3; i++) { // Note the use of let
    funcs.push(function() {
        console.log(i);
    })
}
// call them
for (var j = 0; j < 3; j++) {
    funcs[j]();
}
```

Using a `let` instead of `var` creates a variable `i` unique to each loop iteration.

#### Summary
`let` is extremely useful to have for the vast majority of code. It can greatly enhance your code readability and decrease the chance of a programming error.



[](https://github.com/olov/defs/blob/master/loop-closures.md)
